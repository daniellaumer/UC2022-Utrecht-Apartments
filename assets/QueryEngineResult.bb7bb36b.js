var Me=Object.defineProperty,$e=Object.defineProperties;var De=Object.getOwnPropertyDescriptors;var ne=Object.getOwnPropertySymbols;var Ee=Object.prototype.hasOwnProperty,Ne=Object.prototype.propertyIsEnumerable;var re=(n,e,t)=>e in n?Me(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,G=(n,e)=>{for(var t in e||(e={}))Ee.call(e,t)&&re(n,t,e[t]);if(ne)for(var t of ne(e))Ne.call(e,t)&&re(n,t,e[t]);return n},oe=(n,e)=>$e(n,De(e));import{hE as Ce,hF as Ge,hB as P,hG as xe,hH as K,hI as _e,r as Z,cq as qe,hx as Y,hJ as le,Y as w,t as E,c3 as Pe,a9 as W,hK as Ze,hL as H,hM as Oe,hN as J,bI as je,ca as Be,gz as Ue,hO as Le,hP as ue,hQ as X,hR as Qe,hS as Ye,hT as He,hU as ce,hV as he,hW as Je,hX as Xe,hY as ke,b9 as Ke}from"./vendor.4451b4ce.js";import{WhereClause as We}from"./WhereClause.d6b5dcf7.js";import{T as et,s as tt,m as de,c as fe,V as st,g as it,h as at,y as nt,D as rt,z as ot,f as lt,d as ut}from"./utils.15bf8d44.js";import{t as Fe}from"./json.d1a0fa35.js";const B=[0,0];function Ie(n,e){if(!e)return null;if("x"in e){const t={x:0,y:0};return[t.x,t.y]=n(e.x,e.y,B),e.z!=null&&(t.z=e.z),e.m!=null&&(t.m=e.m),t}if("xmin"in e){const t={xmin:0,ymin:0,xmax:0,ymax:0};return[t.xmin,t.ymin]=n(e.xmin,e.ymin,B),[t.xmax,t.ymax]=n(e.xmax,e.ymax,B),e.hasZ&&(t.zmin=e.zmin,t.zmax=e.zmax,t.hasZ=!0),e.hasM&&(t.mmin=e.mmin,t.mmax=e.mmax,t.hasM=!0),t}return"rings"in e?{rings:me(e.rings,n),hasM:e.hasM,hasZ:e.hasZ}:"paths"in e?{paths:me(e.paths,n),hasM:e.hasM,hasZ:e.hasZ}:"points"in e?{points:Se(e.points,n),hasM:e.hasM,hasZ:e.hasZ}:void 0}function me(n,e){const t=[];for(const s of n)t.push(Se(s,e));return t}function Se(n,e){const t=[];for(const s of n){const i=e(s[0],s[1],[0,0]);t.push(i),s.length>2&&i.push(s[2]),s.length>3&&i.push(s[3])}return t}async function Ve(n,e){if(!e)return;const t=Array.isArray(n)?n.map(s=>Z(s.geometry)&&s.geometry.spatialReference):[n];await qe(t.map(s=>({source:s,dest:e})))}const Te=Ie.bind(null,Ce),ze=Ie.bind(null,Ge);function O(n,e,t,s){if(!n||(t||(t=e,e=n.spatialReference),!Y(e)||!Y(t)||P(e,t)))return n;if(xe(e,t)){const i=K(t)?Te(n):ze(n);return i.spatialReference=t,i}return _e(Fe,[n],e,t,null,s)[0]}class ct{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(e,t,s){if(!e||!e.length||!t||!s||P(t,s))return e;const i={geometries:e,inSpatialReference:t,outSpatialReference:s,resolve:null};return this._jobs.push(i),new Promise(a=>{i.resolve=a,this._timer===null&&(this._timer=setTimeout(this._process,10))})}_process(){this._timer=null;const e=this._jobs.shift();if(!e)return;const{geometries:t,inSpatialReference:s,outSpatialReference:i,resolve:a}=e;xe(s,i)?K(i)?a(t.map(Te)):a(t.map(ze)):a(_e(Fe,t,s,i,null,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const ht=new ct;function vt(n,e,t){return ht.push(n,e,t)}class dt{constructor(e,t){this._cache=new le(e),this._invalidCache=new le(t)}get(e,t){const s=`${t.uid}:${e}`,i=this._cache.get(s);if(i)return i;if(this._invalidCache.get(s)!==void 0)return null;try{const a=We.create(e,t);return this._cache.put(s,a),a}catch{return this._invalidCache.put(s,null),null}}}const ee=new dt(50,500),b="feature-store:unsupported-query",we=" as ",ft=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Rt(n,e){if(!e)return!0;const t=ee.get(e,n);if(!t)throw new w(b,"invalid SQL expression",{where:e});if(!t.isStandardized)throw new w(b,"where clause is not standard",{where:e});return te(n,t.fieldNames,"where clause contains missing fields"),!0}function At(n,e,t){if(!e)return!0;const s=ee.get(e,n);if(!s)throw new w(b,"invalid SQL expression",{having:e});if(!s.isAggregate)throw new w(b,"having does not contain a valid aggregate function",{having:e});const i=s.fieldNames;if(te(n,i,"having contains missing fields"),!s.getExpressions().every(a=>{const{aggregateType:r,field:o}=a,l=n.has(o)&&n.get(o).name;return t.some(u=>{const{onStatisticField:c,statisticType:h}=u;return(n.has(c)&&n.get(c).name)===l&&h.toLowerCase().trim()===r})}))throw new w(b,"expressions in having should also exist in outStatistics",{having:e});return!0}function D(n,e){return n?ee.get(n,e):null}function te(n,e,t,s=!0){const i=[];for(const a of e)if(a!=="*"&&!n.has(a))if(s){const r=be(a);try{const o=D(r,n);if(!o)throw new w(b,"invalid SQL expression",{where:r});if(!o.isStandardized)throw new w(b,"expression is not standard",{clause:o});te(n,o.fieldNames,"expression contains missing fields")}catch(o){const l=o&&o.details;if(l&&(l.clause||l.where))throw o;l&&l.missingFields?i.push(...l.missingFields):i.push(a)}}else i.push(a);if(i.length)throw new w(b,t,{missingFields:i})}function be(n){return n.split(we)[0]}function mt(n){return n.split(we)[1]}function Mt(n,e){const t=e.get(n);return!!t&&!ft.has(t.type)}class q{constructor(e,t,s){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues,this.fieldsIndex=s,this.featureAdapter=t;const i=e.outFields;if(i&&!i.includes("*")){this.outFields=i;let a=0;for(const r of i){const o=be(r),l=this.fieldsIndex.get(o),u=l?null:D(o,s),c=l?l.name:mt(r)||"FIELD_EXP_"+a++;this._fieldDataCache.set(r,{alias:c,clause:u})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,s){const i=s?s.name:t;let a=null;return this._fieldDataCache.has(i)?a=this._fieldDataCache.get(i).clause:s||(a=D(t,this.fieldsIndex),this._fieldDataCache.set(i,{alias:i,clause:a})),s?this.featureAdapter.getAttribute(e,i):a.calculateValue(e,this.featureAdapter)}getNormalizedValue(e,t){const s=t.normalizationType,i=t.normalizationTotal;let a=this.getFieldValue(e,t.field,t.fieldInfo);if(s&&Number.isFinite(a)){const r=this.getFieldValue(e,t.normalizationField,t.normalizationFieldInfo);a=et(a,s,r,i)}return a}getExpressionValue(e,t,s,i){const a={attributes:this.featureAdapter.getAttributes(e),layer:{fields:this.fieldsIndex.fields}},r=i.createExecContext(a,s);return i.executeFunction(t,r)}getExpressionValues(e,t,s,i){const a={fields:this.fieldsIndex.fields};return e.map(r=>{const o={attributes:this.featureAdapter.getAttributes(r),layer:a},l=i.createExecContext(o,s);return i.executeFunction(t,l)})}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:D(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testFeature(e,this.featureAdapter)}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:D(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testSet(e,this.featureAdapter)}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const s={};for(const i of t){const{alias:a,clause:r}=this._fieldDataCache.get(i);s[a]=r?r.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,a)}return s}_processAttributesForDistinctValues(e){if(E(e)||!this.returnDistinctValues)return e;const t=this.outFields,s=[];if(t)for(const r of t){const{alias:o}=this._fieldDataCache.get(r);s.push(e[o])}else for(const r in e)s.push(e[r]);const i=`${(t||["*"]).join(",")}=${s.join(",")}`;let a=this._returnDistinctMap.get(i)||0;return this._returnDistinctMap.set(i,++a),a>1?null:e}}const gt=new Pe({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),ge=Object.freeze({}),pe=new W,pt=new W,k=new W,U={esriGeometryPoint:X,esriGeometryPolyline:Qe,esriGeometryPolygon:Ye,esriGeometryMultipoint:He};function ye(n,e,t,s=n.hasZ,i=n.hasM){if(E(e))return null;const a=n.hasZ&&s,r=n.hasM&&i;if(t){const o=H(k,e,n.hasZ,n.hasM,"esriGeometryPoint",t,s,i);return X(o,a,r)}return X(e,a,r)}function L(n,e,t,s,i,a,r=e,o=t){const l=e&&r,u=t&&o,c=Z(s)?"coords"in s?s:s.geometry:null;if(E(c))return null;if(i){let h=Ze(pt,c,e,t,n,i,r,o);return a&&(h=H(k,h,l,u,n,a)),U[n](h,l,u)}if(a){const h=H(k,c,e,t,n,a,r,o);return U[n](h,l,u)}return Oe(pe,c,e,t,r,o),U[n](pe,l,u)}async function $t(n,e,t){const{outFields:s,orderByFields:i,groupByFieldsForStatistics:a,outStatistics:r}=n;if(s)for(let o=0;o<s.length;o++)s[o]=s[o].trim();if(i)for(let o=0;o<i.length;o++)i[o]=i[o].trim();if(a)for(let o=0;o<a.length;o++)a[o]=a[o].trim();if(r)for(let o=0;o<r.length;o++)r[o].onStatisticField&&(r[o].onStatisticField=r[o].onStatisticField.trim());return n.geometry&&!n.outSR&&(n.outSR=n.geometry.spatialReference),yt(n,e,t)}async function yt(n,e,t){if(!n)return null;let{where:s}=n;if(n.where=s=s&&s.trim(),(!s||/^1 *= *1$/.test(s)||e&&e===s)&&(n.where=null),!n.geometry)return n;let i=await xt(n);if(n.distance=0,n.units=null,n.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:l}=n.geometry;i=J(i),i.spatialReference=l}n.geometry=i,await Ve(i.spatialReference,t);const a=(await je(Be(i)))[0];if(E(a))throw ge;const r=a.toJSON(),o=await O(r,r.spatialReference,t);if(!o)throw ge;return o.spatialReference=t,n.geometry=o,n}async function xt(n){const{geometry:e,distance:t,units:s}=n;if(t==null||"vertexAttributes"in e)return e;const i=e.spatialReference,a=s?gt.fromJSON(s):Ue(i),r=i&&(Le(i)||K(i))?e:await Ve(i,ue).then(()=>O(e,ue));return(await _t())(r.spatialReference,r,t,a)}async function _t(){return(await import("./geometryEngineJSON.2762c1dd.js")).geodesicBuffer}function Q(n){return n&&ve in n?JSON.parse(JSON.stringify(n,Ft)):n}const ve="_geVersion",Ft=(n,e)=>n!==ve?e:void 0;class Dt{constructor(e,t,s){this.items=e,this.query=t,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.fieldsIndex=s.fieldsIndex,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.featureAdapter=s.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new q(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:s,outStatistics:i}=this.query;if(!(t==null?void 0:t.length))return 1;const r=new Map,o=new Map,l=new Set;for(const u of i){const{statisticType:c}=u,h=c!=="exceedslimit"?u.onStatisticField:void 0;if(!o.has(h)){const d=[];for(const f of t){const _=this._getAttributeValues(e,f,r);d.push(_)}o.set(h,this._calculateUniqueValues(d,e.returnDistinctValues))}const m=o.get(h);for(const d in m){const{data:f,items:_}=m[d],F=f.join(",");s&&!e.validateItems(_,s)||l.add(F)}}return l.size}async createQueryResponse(){let e;return this.query.outStatistics?e=this.query.outStatistics.some(t=>t.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry&&(Y(this.query.outSR)&&!P(this.query.geometry.spatialReference,this.query.outSR)?e.queryGeometry=Q(G({spatialReference:this.query.outSR},O(this.query.geometry,this.query.geometry.spatialReference,this.query.outSR))):e.queryGeometry=Q(G({spatialReference:this.query.outSR},this.query.geometry))),e}createSnappingResponse(e,t){const s=this.featureAdapter,i=St(this.hasZ,this.hasM),{x:a,y:r}=e.point,o=typeof e.distance=="number"?e.distance:e.distance.x,l=typeof e.distance=="number"?e.distance:e.distance.y,u={candidates:[]},c=this.geometryType==="esriGeometryPolygon",h=this._getPointCreator(e.point,this.spatialReference,t);for(const m of this.items){const d=s.getGeometry(m);if(E(d))continue;const{coords:f,lengths:_}=d;if(e.types&j.EDGE){let F=0;for(let y=0;y<_.length;y++){const I=_[y];for(let x=0;x<I;x++,F+=i){const S=f[F],p=f[F+1];if(x!==I-1){const g=f[F+i],v=f[F+i+1],{x:$,y:N}=It(a,r,S,p,g,v),V=(a-$)/o,T=(r-N)/l,R=V*V+T*T;R<=1&&u.candidates.push({type:"edge",objectId:s.getObjectId(m),distance:Math.sqrt(R),target:h($,N),start:h(S,p),end:h(g,v)})}}}}if(e.types&j.VERTEX){const F=c?f.length-i:f.length;for(let y=0;y<F;y+=i){const I=f[y],x=f[y+1],S=(a-I)/o,p=(r-x)/l,g=S*S+p*p;g<=1&&u.candidates.push({type:"vertex",objectId:s.getObjectId(m),distance:Math.sqrt(g),target:h(I,x)})}}}return u.candidates.sort((m,d)=>m.distance-d.distance),u}_getPointCreator(e,t,s){const i=Z(s)&&!P(t,s)?a=>O(a,t,s):a=>a;return e.z!=null&&e.m!=null?(a,r)=>i({x:a,y:r,z:e.z,m:e.m}):e.z!=null?(a,r)=>i({x:a,y:r,z:e.z}):e.m!=null?(a,r)=>i({x:a,y:r,m:e.m}):(a,r)=>i({x:a,y:r})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,minValue:o,maxValue:l,scale:u}=e,c=this.fieldsIndex.isDateField(t),h=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,scale:u}),m=tt({normalizationType:a,normalizationField:i,minValue:o,maxValue:l}),d=this.fieldsIndex.get(t),f={value:.5,fieldType:d==null?void 0:d.type},_=ce(d)?de({values:h,supportsNullCount:m,percentileParams:f}):fe({values:h,minValue:o,maxValue:l,useSampleStdDev:!a,supportsNullCount:m,percentileParams:f});return st(_,c)}async createUniqueValuesResponse(e){const{field:t,valueExpression:s,domain:i,returnAllCodedValues:a,scale:r}=e,o=await this._getDataValues({field:t,valueExpression:s,scale:r}),l=it(o);return at(l,i,a)}async createClassBreaksResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:h,scale:m}=e,d=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,scale:m}),f=nt(d,{field:t,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:h});return rt(f,o)}async createHistogramResponse(e){const{field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:h,scale:m}=e,d=await this._getDataValues({field:t,valueExpression:s,normalizationField:i,normalizationType:a,normalizationTotal:r,scale:m});return ot(d,{field:t,normalizationField:i,normalizationType:a,normalizationTotal:r,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:h})}_sortFeatures(e,t,s){if(e.length>1&&t&&t.length)for(const i of t.reverse()){const a=i.split(" "),r=a[0],o=this.fieldsIndex.get(r),l=a[1]&&a[1].toLowerCase()==="desc",u=lt(o==null?void 0:o.type,l);e.sort((c,h)=>{const m=s(c,r,o),d=s(h,r,o);return u(m,d)})}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:s,hasM:i,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:h,resultOffset:m,returnZ:d,returnM:f}=e,_=h!=null&&t.length>(m||0)+h,F=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map(y=>this.fieldsIndex.get(y)));return{exceededTransferLimit:_,features:this._createFeatures(e,t),fields:F,geometryType:s,hasM:i&&f,hasZ:a&&d,objectIdFieldName:r,spatialReference:Q(u||o),transform:c&&he(c)||null}}_createFeatures(e,t){const s=new q(e,this.featureAdapter,this.fieldsIndex),{hasM:i,hasZ:a}=this,{orderByFields:r,quantizationParameters:o,returnGeometry:l,returnCentroid:u,maxAllowableOffset:c,resultOffset:h,resultRecordCount:m,returnZ:d=!1,returnM:f=!1}=e,_=a&&d,F=i&&f;let y=[],I=0;const x=[...t];if(this._sortFeatures(x,r,(p,g,v)=>s.getFieldValue(p,g,v)),l||u){const p=he(o);if(l&&!u)for(const g of x)y[I++]={attributes:s.getAttributes(g),geometry:L(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),c,p,_,F)};else if(!l&&u)for(const g of x)y[I++]={attributes:s.getAttributes(g),centroid:ye(this,this.featureAdapter.getCentroid(g,this),p)};else for(const g of x)y[I++]={attributes:s.getAttributes(g),centroid:ye(this,this.featureAdapter.getCentroid(g,this),p),geometry:L(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),c,p,_,F)}}else for(const p of x){const g=s.getAttributes(p);g&&(y[I++]={attributes:g})}const S=h||0;if(m!=null){const p=S+m;y=y.slice(S,Math.min(y.length,p))}return y}_createExceedsLimitQueryResponse(e){let t=!1,s=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const r of e.outStatistics)if(r.statisticType==="exceedslimit"){s=r.maxPointCount!=null?r.maxPointCount:Number.POSITIVE_INFINITY,i=r.maxRecordCount!=null?r.maxRecordCount:Number.POSITIVE_INFINITY,a=r.maxVertexCount!=null?r.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")t=this.items.length>s;else if(this.items.length>i)t=!0;else{const r=this.hasZ?this.hasM?4:3:this.hasM?3:2,o=this.featureAdapter;t=this.items.reduce((l,u)=>{const c=o.getGeometry(u);return l+(Z(c)&&c.coords.length||0)},0)/r>a}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},s=[],i=new Map,a=new Map,r=new Map,o=new Map,l=new q(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:h,orderByFields:m}=e,d=c&&c.length,f=!!d,_=f&&c[0],F=f&&!this.fieldsIndex.get(_);for(const I of u){const{outStatisticFieldName:x,statisticType:S}=I,p=I,g=S!=="exceedslimit"?I.onStatisticField:void 0,v=S==="percentile_disc"||S==="percentile_cont",$=S==="EnvelopeAggregate"||S==="CentroidAggregate"||S==="ConvexHullAggregate",N=f&&d===1&&(g===_||F)&&S==="count";if(f){if(!r.has(g)){const T=[];for(const R of c){const C=this._getAttributeValues(l,R,i);T.push(C)}r.set(g,this._calculateUniqueValues(T,l.returnDistinctValues))}const V=r.get(g);for(const T in V){const{count:R,data:C,items:se,itemPositions:Re}=V[T],ie=C.join(",");if(!h||l.validateItems(se,h)){const A=o.get(ie)||{attributes:{}};if($){A.aggregateGeometries||(A.aggregateGeometries={});const{aggregateGeometries:z,outStatisticFieldName:M}=await this._getAggregateGeometry(p,se);A.aggregateGeometries[M]=z}else{let z=null;if(N)z=R;else{const M=this._getAttributeValues(l,g,i),ae=Re.map(Ae=>M[Ae]);z=v&&"statisticParameters"in p?this._getPercentileValue(p,ae):this._getStatisticValue(p,ae,null,l.returnDistinctValues)}A.attributes[x]=z}c.forEach((z,M)=>A.attributes[this.fieldsIndex.get(z)?z:`EXPR_${M+1}`]=C[M]),o.set(ie,A)}}}else if($){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:V,outStatisticFieldName:T}=await this._getAggregateGeometry(p,this.items);t.aggregateGeometries[T]=V}else{const V=this._getAttributeValues(l,g,i);t.attributes[x]=v&&"statisticParameters"in p?this._getPercentileValue(p,V):this._getStatisticValue(p,V,a,l.returnDistinctValues)}s.push({name:x,alias:x,type:"esriFieldTypeDouble"})}const y=f?Array.from(o.values()):[t];return this._sortFeatures(y,m,(I,x)=>I.attributes[x]),{fields:s,features:y}}async _getAggregateGeometry(e,t){const s=await import("./geometryEngineJSON.2762c1dd.js"),{statisticType:i,outStatisticFieldName:a}=e,{featureAdapter:r,spatialReference:o,geometryType:l,hasZ:u,hasM:c}=this,h=t.map(f=>L(l,u,c,r.getGeometry(f))),m=s.convexHull(o,h,!0)[0],d={aggregateGeometries:null,outStatisticFieldName:null};if(i==="EnvelopeAggregate"){const f=m?Je(m):J(s.union(o,h));d.aggregateGeometries=oe(G({},f),{spatialReference:o}),d.outStatisticFieldName=a||"extent"}else if(i==="CentroidAggregate"){const f=m?Xe(m):ke(J(s.union(o,h)));d.aggregateGeometries={x:f[0],y:f[1],spatialReference:o},d.outStatisticFieldName=a||"centroid"}else i==="ConvexHullAggregate"&&(d.aggregateGeometries=m,d.outStatisticFieldName=a||"convexHull");return d}_getStatisticValue(e,t,s,i){const{onStatisticField:a,statisticType:r}=e;let o=null;return o=(s==null?void 0:s.has(a))?s.get(a):ce(this.fieldsIndex.get(a))?de({values:t,returnDistinct:i}):fe({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(a,o),o[r==="var"?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:s,statisticParameters:i,statisticType:a}=e,{value:r,orderBy:o}=i,l=this.fieldsIndex.get(s);return ut(t,{value:r,orderBy:o,fieldType:l==null?void 0:l.type,isDiscrete:a==="percentile_disc"})}_getAttributeValues(e,t,s){if(s.has(t))return s.get(t);const i=this.fieldsIndex.get(t),a=this.items.map(r=>e.getFieldValue(r,t,i));return s.set(t,a),a}_getAttributeNormalizedValues(e,t){return this.items.map(s=>e.getNormalizedValue(s,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal}))}async _getAttributeExpressionValues(e,t,s){const{arcadeUtils:i}=await Ke(),a=i.createFunction(t),r=s&&i.getViewInfo(s);return e.getExpressionValues(this.items,a,r,i)}_calculateUniqueValues(e,t){const s={},i=this.items,a=i.length;for(let r=0;r<a;r++){const o=i[r],l=[];for(const c of e)l.push(c[r]);const u=l.join(",");t?s[u]==null&&(s[u]={count:1,data:l,items:[o],itemPositions:[r]}):s[u]==null?s[u]={count:1,data:l,items:[o],itemPositions:[r]}:(s[u].count++,s[u].items.push(o),s[u].itemPositions.push(r))}return s}async _getDataValues(e){const t=new q(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:i,normalizationField:a,normalizationType:r,normalizationTotal:o,scale:l}=e,u=s?{viewingMode:"map",scale:l,spatialReference:this.query.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(t,s,u):this._getAttributeNormalizedValues(t,{field:i,normalizationField:a,normalizationType:r,normalizationTotal:o})}}function It(n,e,t,s,i,a){const r=i-t,o=a-s,l=r*r+o*o,u=(n-t)*r+(e-s)*o,c=Math.min(1,Math.max(0,u/l));return{x:t+r*c,y:s+o*c}}function St(n,e){return n?e?4:3:e?3:2}var j;(function(n){n[n.NONE=0]="NONE",n[n.EDGE=1]="EDGE",n[n.VERTEX=2]="VERTEX"})(j||(j={}));export{j as E,L as J,vt as M,$t as P,ge as U,At as a,Mt as b,te as c,yt as d,Ve as f,O as g,D as l,Rt as o,Dt as v,Q as x};
