import{au as U,oF as z,li as W,oG as C,o1 as H,oH as V,oI as P,k as p,n as g,o as D,hW as J,ax as L,kr as K,oc as Q,oJ as X,nm as Z,nd as _,fH as m,fE as j,oK as h,h4 as O,oL as q,g5 as tt,oM as x,bn as nt,oN as rt,oO as ot,oP as et,b2 as at,r as v,mz as it,oQ as st,mq as M,nB as lt,oR as ct,oS as I,C as f,oT as T,n9 as y,oU as ut,oV as pt,dD as gt,ap as ft,lv as ht,n2 as yt,oW as mt,oX as At,oY as $t,oZ as xt,o_ as Tt,o$ as dt}from"./vendor.5fba8a95.js";function A(t=Mt){return[t[0],t[1],t[2],t[3]]}function It(t,r,n=A()){return U(n,t),n[3]=r,n}function kt(t,r,n=A()){return z($,t,F(t)),z(B,r,F(r)),C($,B,$),wt(n,H(V(n,$)))}function Gt(t){return t}function F(t){return W(t[3])}function wt(t,r){return t[3]=r,t}const Mt=[0,0,1,0],$=P(),B=P();A();var R;let u=R=class extends J{constructor(t){super(t),this.origin=L(),this.translation=L(),this.rotation=A(),this.scale=K(1,1,1),this.geographic=!0}get localMatrix(){const t=m();return Q(t,this.scale),X(t,t,F(this.rotation),this.rotation),Z(t,t,this.translation),t}get localMatrixInverse(){return _(m(),this.localMatrix)}applyLocal(t,r){return j(r,t,this.localMatrix)}applyLocalInverse(t,r){return j(r,t,this.localMatrixInverse)}project(t,r){const n=new Float64Array(t.length),o=h.fromTypedArray(n),e=h.fromTypedArray(t);if(this.geographic){const s=O(r),c=m();return q(r,this.origin,c,s),tt(c,c,this.localMatrix),x(o,e,c),nt(n,s,0,n,r,0,n.length/3),n}const{localMatrix:a,origin:i}=this;rt(a,ot)?et(o,e):x(o,e,a);for(let s=0;s<n.length;s+=3)n[s+0]+=i[0],n[s+1]+=i[1],n[s+2]+=i[2];return n}getOriginPoint(t){const[r,n,o]=this.origin;return new at({x:r,y:n,z:o,spatialReference:t})}equals(t){return v(t)&&this.geographic===t.geographic&&it(this.origin,t.origin)&&st(this.localMatrix,t.localMatrix)}clone(){const t={origin:M(this.origin),translation:M(this.translation),rotation:A(this.rotation),scale:M(this.scale),geographic:this.geographic};return new R(t)}};p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"origin",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"translation",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"rotation",void 0),p([g({type:[Number],nonNullable:!0,json:{write:!0}})],u.prototype,"scale",void 0),p([g({type:Boolean,nonNullable:!0,json:{write:!0}})],u.prototype,"geographic",void 0),p([g()],u.prototype,"localMatrix",null),p([g()],u.prototype,"localMatrixInverse",null),u=R=p([D("esri.geometry.support.MeshTransform")],u);const vt=u;function d(t,r){var n;return t.isGeographic||t.isWebMercator&&((n=r==null?void 0:r.geographic)!=null?n:!0)}function k(t,r,n){return d(r.spatialReference,n)?Et(t,r,n):bt(t,r,n)}function Ft(t,r,n){const{position:o,normal:e,tangent:a}=t;if(f(r))return{position:o,normal:e,tangent:a};const i=r.localMatrix;return k({position:xt(o,new Float64Array(o.length),i),normal:v(e)?Tt(e,new Float32Array(e.length),i):null,tangent:v(a)?dt(a,new Float32Array(a.length),i):null},r.getOriginPoint(n),{geographic:r.geographic})}function St(t,r,n){var o;if(n==null?void 0:n.useTransform){const{position:e,normal:a,tangent:i}=t;return{vertexAttributes:{position:e,normal:a,tangent:i},transform:new vt({origin:[r.x,r.y,(o=r.z)!=null?o:0],geographic:d(r.spatialReference,n)})}}return{vertexAttributes:k(t,r,n),transform:null}}function Rt(t,r,n){return d(r.spatialReference,n)?G(t,r,n):b(t,r,n)}function Yt(t,r,n,o){if(f(r))return Rt(t,n,o);const e=Ft(t,r,n.spatialReference);return n.equals(r.getOriginPoint(n.spatialReference))?b(e,n,o):d(n.spatialReference,o)?G(e,n,o):b(e,n,o)}function bt(t,r,n){const o=new Float64Array(t.position.length),e=t.position,a=r.x,i=r.y,s=r.z||0,{horizontal:c,vertical:w}=N(n?n.unit:null,r.spatialReference);for(let l=0;l<e.length;l+=3)o[l+0]=e[l+0]*c+a,o[l+1]=e[l+1]*c+i,o[l+2]=e[l+2]*w+s;return{position:o,normal:t.normal,tangent:t.tangent}}function Et(t,r,n){const o=r.spatialReference,e=S(r,n,E),a=new Float64Array(t.position.length),i=Nt(t.position,e,o,a),s=I(Y,e);return{position:i,normal:zt(i,a,t.normal,s,o),tangent:Lt(i,a,t.tangent,s,o)}}function Nt(t,r,n,o){x(h.fromTypedArray(o),h.fromTypedArray(t),r);const e=new Float64Array(t.length);return ct(o,e,n)}function zt(t,r,n,o,e){if(f(n))return null;const a=new Float32Array(n.length);return T(y.fromTypedArray(a),y.fromTypedArray(n),o),ut(a,t,r,e,a),a}function Lt(t,r,n,o,e){if(f(n))return null;const a=new Float32Array(n.length);T(y.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT),y.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),o);for(let i=3;i<a.length;i+=4)a[i]=n[i];return pt(a,t,r,e,a),a}function b(t,r,n){const o=new Float64Array(t.position.length),e=t.position,a=r.x,i=r.y,s=r.z||0,{horizontal:c,vertical:w}=N(n?n.unit:null,r.spatialReference);for(let l=0;l<e.length;l+=3)o[l+0]=(e[l+0]-a)/c,o[l+1]=(e[l+1]-i)/c,o[l+2]=(e[l+2]-s)/w;return{position:o,normal:t.normal,tangent:t.tangent}}function G(t,r,n){const o=r.spatialReference;S(r,n,E);const e=_(_t,E),a=new Float64Array(t.position.length),i=jt(t.position,o,e,a),s=I(Y,e);return{position:i,normal:Bt(t.normal,t.position,a,o,s),tangent:Pt(t.tangent,t.position,a,o,s)}}function S(t,r,n){q(t.spatialReference,[t.x,t.y,t.z||0],n,O(t.spatialReference));const{horizontal:o,vertical:e}=N(r?r.unit:null,t.spatialReference);return lt(n,n,[o,o,e]),n}function jt(t,r,n,o){const e=mt(t,r,o),a=h.fromTypedArray(e),i=new Float64Array(e.length),s=h.fromTypedArray(i);return x(s,a,n),i}function Bt(t,r,n,o,e){if(f(t))return null;const a=At(t,r,n,o,new Float32Array(t.length)),i=y.fromTypedArray(a);return T(i,i,e),a}function Pt(t,r,n,o,e){if(f(t))return null;const a=$t(t,r,n,o,new Float32Array(t.length)),i=y.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT);return T(i,i,e),a}function N(t,r){if(f(t))return Ot;const n=r.isGeographic?1:gt(r),o=r.isGeographic?1:ft(r),e=ht(1,t,"meters");return{horizontal:e*n,vertical:e*o}}const E=m(),_t=m(),Y=yt(),Ot={horizontal:1,vertical:1};export{vt as L,Rt as M,Yt as P,Ft as _,A as a,F as b,It as c,kt as g,St as k,Gt as l,d as r,k as x};
